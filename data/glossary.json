{
   "a b testing": {
      "B": "A statistical way of comparing two (or more) techniques. A/B testing aims to determine which technique performs better. Also understands whether the difference is statistically significant. A/B testing usually considers only two techniques using one measurement, but it can be applied to any finite number of techniques and measures."
   },
   "accuracy": {
      "B": "The fraction of predictions that a classification model got right. In multi-class classification, Accuracy is equal to Correct Predictions divided by the Total Number Of Examples. In binary classification, Accuracy is equal to True Positives plus True Negatives divided by the Total Number Of Examples"
   },
   "activation function": {
      "B": "A function (for example, ReLU or sigmoid) that takes in the weighted sum of all of the inputs from the previous layer and then generates and passes an output value (typically nonlinear) to the next layer."
   },
   "ada grad": {
      "B": "A sophisticated gradient descent algorithm that rescales the gradients of each parameter. It adapts the learning rate to the parameters, performing smaller updates "
   },
   "auc": {
      "B": "Area under the R O C curve is an evaluation metric. It provides an aggregate measure of performance across all possible classification thresholds.. A U C measures the entire two-dimensional area underneath the entire R O C curve from (0,0) to (1,1)."
   },
   "area under the curve": {
      "B": "Area under the R O C curve is an evaluation metric. It provides an aggregate measure of performance across all possible classification thresholds.. A U C measures the entire two-dimensional area underneath the entire R O C curve from (0,0) to (1,1)."
   },
   "automation bias": {
      "B": "When a human decision maker favors recommendations made by an automated decision-making system over information made without automation, even when the automated decision-making system makes errors."
   },
   "backpropagation": {
      "B": "The primary algorithm for performing gradient descent on neural networks. First, the output values of each node are calculated (and cached) in a forward pass. Then, the partial derivative of the error with respect to each parameter is calculated in a backward pass through the graph."
   },
   "baseline": {
      "B": "A simple model or heuristic used as reference point for comparing how well a model is performing. A baseline helps model developers quantify the minimal, expected performance on a particular problem."
   },
   "batch": {
      "B": "The set of examples used in one iteration (that is, one gradient update) of model training."
   },
   "batch size": {
      "B": "The number of examples in a batch. For example, the batch size of SGD is 1, while the batch size of a mini-batch is usually between 10 and 1000. Batch size is usually fixed during training and inference"
   },
   "bias": {
      "B": "An intercept or offset from an origin. Bias (also known as the bias term) is referred to as b or w0 in machine learning models."
   },
   "bias in ethics": {
      "B": "1. Stereotyping, prejudice or favoritism towards some things, people, or groups over others. These biases can affect collection and interpretation of data, the design of a system, and how users interact with a system. Forms of this type of bias include: automation bias; confirmation bias; experimenter’s bias; group attribution bias; implicit bias; in-group bias; out-group homogeneity bias. 2. Systematic error introduced by a sampling or reporting procedure. Forms of this type of bias include: coverage bias; non-response bias; participation bias; reporting bias; sampling bias; selection bias."
   },
   "binary classification": {
      "B": "A type of classification task that outputs one of two mutually exclusive classes. For example, a machine learning model that evaluates email messages and outputs either \"spam\" or \"not spam\" is a binary classifier."
   },
   "binning": {
      "B": "Converting a (usually continuous) feature into multiple binary features called buckets or bins. For example, instead of representing temperature as a single continuous floating-point feature, you could chop ranges of temperatures into discrete bins. Given temperature data sensitive to a tenth of a degree, all temperatures between 0.0 and 15.0 degrees could be put into one bin, 15.1 to 30.0 degrees could be a second bin, and 30.1 to 50.0 degrees could be a third bin."
   },
   "bucketing": {
      "B": "Converting a (usually continuous) feature into multiple binary features called buckets or bins. For example, instead of representing temperature as a single continuous floating-point feature, you could chop ranges of temperatures into discrete bins. Given temperature data sensitive to a tenth of a degree, all temperatures between 0.0 and 15.0 degrees could be put into one bin, 15.1 to 30.0 degrees could be a second bin, and 30.1 to 50.0 degrees could be a third bin."
   },
   "calibration layer": {
      "B": "A post-prediction adjustment, typically to account for prediction bias. The adjusted predictions and probabilities should match the distribution of an observed set of labels."
   },
   "candidate sampling": {
      "B": "A training-time optimization in which a probability is calculated for all the positive labels, using, for example, softmax, but only for a random sample of negative labels. For example, if we have an example labeled beagle and dog candidate sampling computes the predicted probabilities and corresponding loss terms for the beagle and dog class outputs in addition to a random subset of the remaining classes (cat, lollipop, fence). The idea is that the negative classes can learn from less frequent negative reinforcement as long as positive classes always get proper positive reinforcement, and this is indeed observed empirically. The motivation for candidate sampling is a computational efficiency win from not computing predictions for all negatives."
   },
   "categorical data": {
      "B": "Features having a discrete set of possible values. For example, consider a categorical feature named house style, which has a discrete set of three possible values: Tudor, ranch, colonial. By representing house style as categorical data, the model can learn the separate impacts of Tudor, ranch, and colonial on house price. Categorical features are sometimes called discrete features. Contrast with numerical data."
   },
   "centroid": {
      "B": "The center of a cluster as determined by a k-means or k-median algorithm. For instance, if k is 3, then the k-means or k-median algorithm finds 3 centroids."
   },
   "checkpoint": {
      "B": "Data that captures the state of the variables of a model at a particular time. Checkpoints enable exporting model weights, as well as performing training across multiple sessions. Checkpoints also enable training to continue past errors (for example, job preemption)."
   },
   "class": {
      "B": "One of a set of enumerated target values for a label. For example, in a binary classification model that detects spam, the two classes are spam and not spam. In a multi-class classification model that identifies dog breeds, the classes would be poodle, beagle, pug, and so on."
   },
   "class imbalanced data set": {
      "B": "A binary classification problem in which the labels for the two classes have significantly different frequencies. For example, a disease data set in which 0.0001 of examples have positive labels and 0.9999 have negative labels is a class-imbalanced problem, but a football game predictor in which 0.51 of examples label one team winning and 0.49 label the other team winning is not a class-imbalanced problem."
   },
   "classification model": {
      "B": "A type of machine learning model for distinguishing among two or more discrete classes. For example, a natural language processing classification model could determine whether an input sentence was in French, Spanish, or Italian. Compare with regression model."
   },
   "classification threshold": {
      "B": "A scalar-value criterion that is applied to a model's predicted score in order to separate the positive class from the negative class. Used when mapping logistic regression results to binary classification. For example, consider a logistic regression model that determines the probability of a given email message being spam. If the classification threshold is 0.9, then logistic regression values above 0.9 are classified as spam and those below 0.9 are classified as not spam."
   },
   "clustering": {
      "B": "Grouping related examples, particularly during unsupervised learning. Once all the examples are grouped, a human can optionally supply meaning to each cluster. For example, the k-means algorithm clusters examples based on their proximity to a centroid."
   },
   "collaborative filtering": {
      "B": "Making predictions about the interests of one user based on the interests of many other users. Collaborative filtering is often used in recommendation systems."
   },
   "confirmation bias": {
      "B": "The tendency to search for, interpret, favor, and recall information in a way that confirms one's preexisting beliefs or hypotheses. Machine learning developers may inadvertently collect or label data in ways that influence an outcome supporting their existing beliefs. Confirmation bias is a form of implicit bias. Experimenter's bias is a form of confirmation bias in which an experimenter continues training models until a preexisting hypothesis is confirmed."
   },
   "confusion matrix": {
      "B": "An NxN table that summarizes how successful a classification model's predictions were; that is, the correlation between the label and the model's classification. One axis of a confusion matrix is the label that the model predicted, and the other axis is the actual label. Confusion matrices contain sufficient information to calculate a variety of performance metrics, including precision and recall."
   },
   "continuous feature": {
      "B": "A floating-point feature with an infinite range of possible values. Contrast with discrete feature."
   },
   "convergence": {
      "B": "Informally, often refers to a state reached during training in which training loss and validation loss change very little or not at all with each iteration after a certain number of iterations. In other words, a model reaches convergence when additional training on the current data will not improve the model."
   },
   "convex function": {
      "B": "A function in which the region above the graph of the function is a convex set. The prototypical convex function is shaped something like the letter U. A strictly convex function has exactly one local minimum point, which is also the global minimum point. The classic U-shaped functions are strictly convex functions. A lot of the common loss functions, including the following, are convex functions:\nL2 loss, Log Loss, L1 regularization, L2 regularization. Many variations of gradient descent are guaranteed to find a point close to the minimum of a strictly convex function. Similarly, many variations of stochastic gradient descent have a high probability (though, not a guarantee) of finding a point close to the minimum of a strictly convex function."
   },
   "convex optimization": {
      "B": "The process of using mathematical techniques such as gradient descent to find the minimum of a convex function."
   },
   "convex set": {
      "B": "A subset of Euclidean space such that a line drawn between any two points in the subset remains completely within the subset."
   },
   "convolution": {
      "B": "Mathematically a mixture of two functions. In machine learning, a convolution mixes the convolutional filter and the input matrix in order to train weights. The term \"convolution\" in machine learning is often a shorthand way of referring to either convolutional operation or convolutional layer."
   },
   "convolutional filter": {
      "B": "One of the two actors in a convolutional operation. (The other actor is a slice of an input matrix.) A convolutional filter is a matrix having the same rank as the input matrix, but a smaller shape. For example, given a 28x28 input matrix, the filter could be any 2D matrix smaller than 28x28. In machine learning, convolutional filters are typically seeded with random numbers and then the network trains the ideal values."
   },
   "convolutional layer": {
      "B": "A layer of a deep neural network in which a convolutional filter passes along an input matrix."
   },
   "convolutional neural network": {
      "B": "A neural network in which at least one layer is a convolutional layer. A typical convolutional neural network consists of some combination of the following layers: convolutional layers; pooling layers; dense layers. Convolutional neural networks have had great success in certain kinds of problems, such as image recognition."
   },
   "convolutional operation": {
      "B": "The following two-step mathematical operation: Element-wise multiplication of the convolutional filter and a slice of an input matrix. (The slice of the input matrix has the same rank and size as the convolutional filter.) Summation of all the values in the resulting product matrix. A convolutional layer consists of a series of convolutional operations, each acting on a different slice of the input matrix."
   },
   "cost": {
      "B": "Synonym for loss."
   },
   "coverage bias": {
      "B": "Check selection bias."
   },
   "cross entropy": {
      "B": "Cross-entropy quantifies the difference between two probability distributions. In information theory, the cross entropy between two probability distributions p and q over the same underlying set of events measures the average number of bits needed to identify an event drawn from the set, if a coding scheme is used that is optimized for an \"unnatural\" probability distribution q, rather than the \"true\" distribution p"
   },
   "data analysis": {
      "B": "Obtaining an understanding of data by considering samples, measurement, and visualization. Data analysis can be particularly useful when a data set is first received, before one builds the first model. It is also crucial in understanding experiments and debugging problems with the system."
   },
   "data frame": {
      "B": "A popular datatype for representing data sets in Pandas. A DataFrame is analogous to a table. Each column of the DataFrame has a name (a header), and each row is identified by a number."
   },
   "data set": {
      "B": "A collection of examples."
   },
   "dense layer": {
      "B": "Synonym for fully connected layer."
   },
   "deep model": {
      "B": "A type of neural network containing multiple hidden layers. Deep models rely on trainable nonlinearities. Contrast with wide model."
   },
   "dense feature": {
      "B": "A feature in which most values are non-zero, typically a Tensor of floating-point values. Contrast with sparse feature."
   },
   "discrete feature": {
      "B": "A feature with a finite set of possible values. For example, a feature whose values may only be animal, vegetable, or mineral is a discrete (or categorical) feature. Contrast with continuous feature."
   },
   "dropout regularization": {
      "B": "A form of regularization useful in training neural networks. Dropout regularization works by removing a random selection of a fixed number of the units in a network layer for a single gradient step. The more units dropped out, the stronger the regularization."
   },
   "dynamic model": {
      "B": "A model that is trained online in a continuously updating fashion. That is, data is continuously entering the model."
   },
   "early stopping": {
      "B": "A method for regularization that involves ending model training before training loss finishes decreasing. In early stopping, you end model training when the loss on a validation data set starts to increase, that is, when generalization performance worsens."
   },
   "embeddings": {
      "B": "A categorical feature represented as a continuous-valued feature. Typically, an embedding is a translation of a high-dimensional vector into a low-dimensional space. A several-hundred-element (low-dimensional) dense vector in which each element holds a floating-point value between 0 and 1. This is an embedding."
   },
   "empirical risk minimization": {
      "B": "Choosing the function that minimizes loss on the training set. Contrast with structural risk minimization."
   },
   "ensemble": {
      "B": "A merger of the predictions of multiple models. You can create an ensemble via one or more of the following: different initializations; different hyperparameters; different overall structure; Deep and wide models are a kind of ensemble."
   },
   "epoch": {
      "B": "A full training pass over the entire data set such that each example has been seen once. Thus, an epoch represents N/batch size training iterations, where N is the total number of examples."
   },
   "example": {
      "B": "One row of a data set. An example contains one or more features and possibly a label. See also labeled example and unlabeled example."
   },
   "experimenter's bias": {
      "B": "Check confirmation bias."
   },
   "false negative": {
      "B": "An example in which the model mistakenly predicted the negative class. For example, the model inferred that a particular email message was not spam (the negative class), but that email message actually was spam."
   },
   "false positive": {
      "B": "An example in which the model mistakenly predicted the positive class. For example, the model inferred that a particular email message was spam (the positive class), but that email message was actually not spam."
   },
   "false positive rate": {
      "B": "The x-axis in an R O C curve. False Positive Rate is equal to False Positives divided by the sum of False Positives and True Negatives"
   },
   "feature": {
      "B": "An input variable used in making predictions."
   },
   "feature cross": {
      "B": "A synthetic feature formed by crossing (multiplying or taking a Cartesian product of) individual features. Feature crosses help represent nonlinear relationships."
   },
   "feature engineering": {
      "B": "The process of determining which features might be useful in training a model, and then converting raw data from log files and other sources into said features. Feature engineering is sometimes called feature extraction."
   },
   "feature set": {
      "B": "The group of features your machine learning model trains on. For example, postal code, property size, and property condition might comprise a simple feature set for a model that predicts housing prices."
   },
   "few shot learning": {
      "B": "A machine learning approach, often used for object classification, designed to learn effective classifiers from only a small number of training examples. Check also one-shot learning."
   },
   "full softmax": {
      "B": "Check softmax. Contrast with candidate sampling."
   },
   "fully connected layer": {
      "B": "A hidden layer in which each node is connected to every node in the subsequent hidden layer. A fully connected layer is also known as a dense layer."
   },
   "generalization": {
      "B": "Refers to your model's ability to make correct predictions on new, previously unseen data as opposed to the data used to train the model."
   },
   "generalized linear model": {
      "B": "A generalization of least squares regression models, which are based on Gaussian noise, to other types of models based on other types of noise, such as Poisson noise or categorical noise. Examples of generalized linear models include: logistic regression, multi-class regression, least squares regression. The power of a generalized linear model is limited by its features. Unlike a deep model, a generalized linear model cannot \"learn new features.\""
   },
   "gradient": {
      "B": "The vector of partial derivatives with respect to all of the independent variables. In machine learning, the gradient is the the vector of partial derivatives of the model function. The gradient points in the direction of steepest ascent."
   },
   "gradient clipping": {
      "B": "Capping gradient values before applying them. Gradient clipping helps ensure numerical stability and prevents exploding gradients."
   },
   "gradient descent": {
      "B": "A technique to minimize loss by computing the gradients of loss with respect to the model's parameters, conditioned on training data. Informally, gradient descent iteratively adjusts parameters, gradually finding the best combination of weights and bias to minimize loss."
   },
   "group attribution bias": {
      "B": "Assuming that what is true for an individual is also true for everyone in that group. The effects of group attribution bias can be exacerbated if a convenience sample is used for data collection. In a non-representative sample, attributions may be made that do not reflect reality. Check also out-group homogeneity bias and in-group bias."
   },
   "heuristic": {
      "B": "A practical and nonoptimal solution to a problem, which is sufficient for making progress or for learning from."
   },
   "hidden layer": {
      "B": "A synthetic layer in a neural network between the input layer (that is, the features) and the output layer (the prediction). A neural network contains one or more hidden layers."
   },
   "hinge loss": {
      "B": "A family of loss functions for classification designed to find the decision boundary as distant as possible from each training example, thus maximizing the margin between examples and the boundary. KSVMs use hinge loss (or a related function, such as squared hinge loss)."
   },
   "holdout data": {
      "B": "Examples intentionally not used (\"held out\") during training. The validation data set and test data set are examples of holdout data. Holdout data helps evaluate your model's ability to generalize to data other than the data it was trained on. The loss on the holdout set provides a better estimate of the loss on an unseen data set."
   },
   "hyperparameter": {
      "B": "The \"knobs\" that you tweak during successive runs of training a model. For example, learning rate is a hyperparameter. Contrast with parameter."
   },
   "hyperplane": {
      "B": "A boundary that separates a space into two subspaces. For example, a line is a hyperplane in two dimensions and a plane is a hyperplane in three dimensions. More typically in machine learning, a hyperplane is the boundary separating a high-dimensional space. Kernel Support Vector Machines use hyperplanes to separate positive classes from negative classes, often in a very high-dimensional space."
   },
   "implicit bias": {
      "B": "Automatically making an association or assumption based on one’s mental models and memories. Implicit bias can affect the following:\nHow data is collected and classified. How ML systems are designed and developed. For example, when building a classifier to identify wedding photos, an engineer may use the presence of a white dress in a photo as a feature. However, white dresses have been customary only during certain eras and in certain cultures. See also confirmation bias."
   },
   "independently and identically distributed": {
      "B": "Data drawn from a distribution that doesn't change, and where each value drawn doesn't depend on values that have been drawn previously. An i.i.d. is a useful mathematical construct but almost never exactly found in the real world. For example, the distribution of visitors to a web page may be i.i.d. over a brief window of time; that is, the distribution doesn't change during that brief window and one person's visit is generally independent of another's visit. However, if you expand that window of time, seasonal differences in the web page's visitors may appear."
   },
   "iid": {
      "B": "I.I.D stands for independently and identically distributed. Data drawn from a distribution that doesn't change, and where each value drawn doesn't depend on values that have been drawn previously. An i.i.d. is a useful mathematical construct but almost never exactly found in the real world. For example, the distribution of visitors to a web page may be i.i.d. over a brief window of time; that is, the distribution doesn't change during that brief window and one person's visit is generally independent of another's visit. However, if you expand that window of time, seasonal differences in the web page's visitors may appear."
   },
   "inference": {
      "B": "In machine learning, often refers to the process of making predictions by applying the trained model to unlabeled examples."
   },
   "in group bias": {
      "B": "Showing partiality to one's own group or own characteristics. If testers or raters consist of the machine learning developer's friends, family, or colleagues, then in-group bias may invalidate product testing or the data set. In-group bias is a form of group attribution bias."
   },
   "input layer": {
      "B": "The first layer (the one that receives the input data) in a neural network."
   },
   "instance": {
      "B": "Synonym for example."
   },
   "interpretability": {
      "B": "The degree to which a model's predictions can be readily explained. Deep models are often non-interpretable; that is, a deep model's different layers can be hard to decipher. By contrast, linear regression models and wide models are typically far more interpretable."
   },
   "inter-rater agreement": {
      "B": "A measurement of how often human raters agree when doing a task. Also sometimes called inter-annotator agreement or inter-rater reliability. Cohen's kappa is one of the most popular inter-rater agreement measurements."
   },
   "iteration": {
      "B": "A single update of a model's weights during training. An iteration consists of computing the gradients of the parameters with respect to the loss on a single batch of data."
   },
   "k means": {
      "B": "A popular clustering algorithm that groups examples in unsupervised learning. It iteratively determines the best k center points (known as centroids). Assigns each example to the closest centroid. Those examples nearest the same centroid belong to the same group. The k-means algorithm picks centroid locations to minimize the cumulative square of the distances from each example to its closest centroid."
   },
   "k median": {
      "B": "A clustering algorithm closely related to k-means. In k-means, centroids are determined by minimizing the sum of the squares of the distance between a centroid candidate and each of its examples. In k-median, centroids are determined by minimizing the sum of the distance between a centroid candidate and each of its examples. k-means relies on the Euclidean distance. k-median relies on the Manhattan distance."
   },
   "keras": {
      "B": "A popular Python machine learning API. Keras runs on several deep learning frameworks, like TensorFlow, theano, CNTK"
   },
   "kernel support vector machines": {
      "B": "A classification algorithm that seeks to maximize the margin between positive and negative classes by mapping input data vectors to a higher dimensional space. Consider a classification problem in which the input data set consists of a hundred features. In order to maximize the margin between positive and negative classes, KSVMs could internally map those features into a million-dimension space. KSVMs uses a loss function called hinge loss."
   },
   "k svm": {
      "B": "A classification algorithm that seeks to maximize the margin between positive and negative classes by mapping input data vectors to a higher dimensional space. Consider a classification problem in which the input data set consists of a hundred features. In order to maximize the margin between positive and negative classes, KSVMs could internally map those features into a million-dimension space. KSVMs uses a loss function called hinge loss."
   },
   "l1 loss": {
      "B": "Loss function based on the absolute value of the difference between the values that a model is predicting and the actual values of the labels. L1 loss is less sensitive to outliers than L2 loss."
   },
   "l1 regularization": {
      "B": "A type of regularization that penalizes weights in proportion to the sum of the absolute values of the weights. In models relying on sparse features, L1 regularization helps drive the weights of irrelevant or barely relevant features to exactly 0, which removes those features from the model. Contrast with L2 regularization."
   },
   "l2 loss": {
      "B": "The loss function used in linear regression. (Also known as squared loss.) This function calculates the squares of the difference between a model's predicted value for a labeled example and the actual value of the label. Due to squaring, this loss function amplifies the influence of bad predictions. That is, squared loss reacts more strongly to outliers than L1 loss."
   },
   "l2 regularization": {
      "B": "A type of regularization that penalizes weights in proportion to the sum of the squares of the weights. L2 regularization helps drive outlier weights closer to 0 but not quite to 0. (Contrast with L1 regularization.) L2 regularization always improves generalization in linear models."
   },
   "label": {
      "B": "In supervised learning, the \"answer\" or \"result\" portion of an example. Each example in a labeled data set consists of one or more features and a label. For instance, in a housing data set, the features might include the number of bedrooms, the number of bathrooms, and the age of the house, while the label might be the house's price."
   },
   "labeled example": {
      "B": "An example that contains features and a label. In supervised training, models learn from labeled examples."
   },
   "layer": {
      "B": "A set of neurons in a neural network that process a set of input features, or the output of those neurons."
   },
   "learning rate": {
      "B": "A scalar used to train a model via gradient descent. During each iteration, the gradient descent algorithm multiplies the learning rate by the gradient. The resulting product is called the gradient step. Learning rate is a key hyperparameter."
   },
   "least squares regression": {
      "B": "A linear regression model trained by minimizing L2 Loss."
   },
   "linear regression": {
      "B": "A type of regression model that outputs a continuous value from a linear combination of input features."
   },
   "logistic regression": {
      "B": "A model that generates a probability for each possible discrete label value in classification problems by applying a sigmoid function to a linear prediction. Although logistic regression is often used in binary classification problems, it can also be used in multi-class classification problems (where it becomes called multi-class logistic regression or multinomial regression)."
   },
   "logits": {
      "B": "The vector of raw (non-normalized) predictions that a classification model generates, which is ordinarily then passed to a normalization function. If the model is solving a multi-class classification problem, logits typically become an input to the softmax function. The softmax function then generates a vector of (normalized) probabilities with one value for each possible class. In addition, logits sometimes refer to the element-wise inverse of the sigmoid function. "
   },
   "log-odds": {
      "B": "The logarithm of the odds of some event. If the event refers to a binary probability, then odds refers to the ratio of the probability of success (p) to the probability of failure (1-p). For example, suppose that a given event has a 90% probability of success and a 10% probability of failure. In this case, odds is calculated as follows: p divided by p minus 1 that is 0.9 divided by 0.1 equal to 9. The log-odds is simply the logarithm of the odds. The log-odds are the inverse of the sigmoid function."
   },
   "loss": {
      "B": "A measure of how far a model's predictions are from its label. Or, to phrase it more pessimistically, a measure of how bad the model is. To determine this value, a model must define a loss function. For example, linear regression models typically use mean squared error for a loss function, while logistic regression models use Log Loss"
   },
   "machine learning": {
      "B": "A program or system that trains a predictive model from input data. The system uses the learned model to make useful predictions from new (never-before-seen) data drawn from the same distribution as the one used to train the model. Machine learning also refers to the field of study concerned with these programs or systems."
   },
   "mean squared error": {
      "B": "The average squared loss per example. MSE is calculated by dividing the squared loss by the number of examples."
   },
   "mse": {
      "B": "The average squared loss per example. MSE is calculated by dividing the squared loss by the number of examples."
   },
   "metric": {
      "B": "A number that you care about. May or may not be directly optimized in a machine-learning system. A metric that your system tries to optimize is called an objective."
   },
   "mini batch": {
      "B": "A small, randomly selected subset of the entire batch of examples run together in a single iteration of training or inference. The batch size of a mini-batch is usually between 10 and 1,000. It is much more efficient to calculate the loss on a mini-batch than on the full training data."
   },
   "mini batch stochastic gradient descent": {
      "B": "A gradient descent algorithm that uses mini-batches. In other words, mini-batch SGD estimates the gradient based on a small subset of the training data. Vanilla SGD uses a mini-batch of size 1."
   },
   "mini batch SGD": {
      "B": "A gradient descent algorithm that uses mini-batches. In other words, mini-batch SGD estimates the gradient based on a small subset of the training data. Vanilla SGD uses a mini-batch of size 1."
   },
   "ml": {
      "B": "Abbreviation for machine learning."
   },
   "model": {
      "B": "The representation of what an ML system has learned from the training data."
   },
   "model training": {
      "B": "The process of determining the best model."
   },
   "momentum": {
      "B": "A sophisticated gradient descent algorithm in which a learning step depends not only on the derivative in the current step, but also on the derivatives of the step(s) that immediately preceded it. Momentum involves computing an exponentially weighted moving average of the gradients over time, analogous to momentum in physics. Momentum sometimes prevents learning from getting stuck in local minima."
   },
   "multi class classification": {
      "B": "Classification problems that distinguish among more than two classes. For example, there are approximately 128 species of maple trees, so a model that categorized maple tree species would be multi-class. Conversely, a model that divided emails into only two categories (spam and not spam) would be a binary classification model."
   },
   "multinomial classification": {
      "B": "Synonym for multi-class classification."
   },
   "nan trap": {
      "B": "When one number in your model becomes a NaN during training, which causes many or all other numbers in your model to eventually become a NaN. NaN is an abbreviation for \"Not a Number.\""
   },
   "negative class": {
      "B": "In binary classification, one class is termed positive and the other is termed negative. The positive class is the thing we're looking for and the negative class is the other possibility. For example, the negative class in a medical test might be \"not tumor.\" The negative class in an email classifier might be \"not spam.\" Check also positive class."
   },
   "neural network": {
      "B": "A model that, taking inspiration from the brain, is composed of layers (at least one of which is hidden) consisting of simple connected units or neurons followed by nonlinearities."
   },
   "neuron": {
      "B": "A node in a neural network, typically taking in multiple input values and generating one output value. The neuron calculates the output value by applying an activation function (nonlinear transformation) to a weighted sum of input values."
   },
   "node": {
      "B": "A neuron in a hidden layer."
   },
   "non response bias": {
      "B": "Check selection bias."
   },
   "normalization": {
      "B": "The process of converting an actual range of values into a standard range of values, typically -1 to +1 or 0 to 1. For example, suppose the natural range of a certain feature is 800 to 6,000. Through subtraction and division, you can normalize those values into the range -1 to +1."
   },
   "numerical data": {
      "B": "Features represented as integers or real-valued numbers. For example, in a real estate model, the size of a house is represented as numerical data. Representing a feature as numerical data indicates that the feature's values have a mathematical relationship to each other and possibly to the label. Not all integer data should be represented as numerical data. For example, integer postal codes should not be represented as numerical data in models. That's because a postal code of 20000 is not twice (or half) as potent as a postal code of 10000. Postal codes should be represented as categorical data instead. Numerical features are sometimes called continuous features."
   },
   "numpy": {
      "B": "An open-source math library that provides efficient array operations in Python. pandas is built on numpy."
   },
   "objective": {
      "B": "A metric that your algorithm is trying to optimize."
   },
   "offline inference": {
      "B": "Generating a group of predictions, storing those predictions, and then retrieving those predictions on demand. Contrast with online inference."
   },
   "one hot encoding": {
      "B": "A sparse vector in which: One element is set to 1. All other elements are set to 0. One-hot encoding is commonly used to represent strings or identifiers that have a finite set of possible values. For example, suppose a given botany data set chronicles 15,000 different species, each denoted with a unique string identifier. As part of feature engineering, you'll probably encode those string identifiers as one-hot vectors with a size of 15,000. "
   },
   "one shot learning": {
      "B": "A machine learning approach, often used for object classification, designed to learn effective classifiers from a single training example."
   },
   "one vs.all": {
      "B": "Given a classification problem with N possible solutions, a one-vs.-all solution consists of N separate binary classifiers—one binary classifier for each possible outcome. For example, given a model that classifies examples as animal, vegetable, or mineral, a one-vs.-all solution would provide the following three separate binary classifiers: animal vs. not animal, vegetable vs. not vegetable, mineral vs. not mineral"
   },
   "online inference": {
      "B": "Generating predictions on demand. Contrast with offline inference."
   },
   "optimizer": {
      "B": "A specific implementation of the gradient descent algorithm. Different optimizers may leverage one or more of the following concepts to enhance the effectiveness of gradient descent on a given training set: momentum, update frequency (AdaGrad - ADAptive GRADient descent; Adam - ADAptive with Momentum; RMS Prop), sparsity/regularization, more complex math"
   },
   "out group homogeneity bias": {
      "B": "The tendency to see out-group members as more alike than in-group members when comparing attitudes, values, personality traits, and other characteristics. In-group refers to people you interact with regularly; out-group refers to people you do not interact with regularly. If you create a data set by asking people to provide attributes about out-groups, those attributes may be less nuanced and more stereotyped than attributes that participants list for people in their in-group. Out-group homogeneity bias is a form of group attribution bias. See also in-group bias."
   },
   "outliers": {
      "B": "Values distant from most other values. In machine learning, any of the following are outliers: Weights with high absolute values. Predicted values relatively far away from the actual values. Input data whose values are more than roughly 3 standard deviations from the mean. Outliers often cause problems in model training."
   },
   "output layer": {
      "B": "The \"final\" layer of a neural network. The layer containing the answers."
   },
   "overfitting": {
      "B": "Creating a model that matches the training data so closely that the model fails to make correct predictions on new data."
   },
   "pandas": {
      "B": "A column-oriented data analysis API. Many ML frameworks support pandas data structures as input."
   },
   "parameter": {
      "B": "A variable of a model that the ML system trains on its own. For example, weights are parameters whose values the ML system gradually learns through successive training iterations. Contrast with hyperparameter."
   },
   "parameter update": {
      "B": "The operation of adjusting a model's parameters during training, typically within a single iteration of gradient descent."
   },
   "partial derivative": {
      "B": "A derivative in which all but one of the variables is considered a constant. For example, the partial derivative of f(x, y) with respect to x is the derivative of f considered as a function of x alone (that is, keeping y constant). The partial derivative of f with respect to x focuses only on how x is changing and ignores all other variables in the equation."
   },
   "participation bias": {
      "B": "Synonym for non-response bias. Check selection bias."
   },
   "performance": {
      "B": "Within ML, performance answers the following question: How correct is this model? That is, how good are the model's predictions?"
   },
   "perplexity": {
      "B": "One measure of how well a model is accomplishing its task. For example, suppose your task is to read the first few letters of a word a user is typing on a smartphone keyboard, and to offer a list of possible completion words. Perplexity, P, for this task is approximately the number of guesses you need to offer in order for your list to contain the actual word the user is trying to type. Perplexity is related to cross-entropy as follows: P is equal to 2 to the power of minus of cross-entropy"
   },
   "pipeline": {
      "B": "The infrastructure surrounding a machine learning algorithm. A pipeline includes gathering the data, putting the data into training data files, training one or more models, and exporting the models to production."
   },
   "pooling": {
      "B": "Reducing a matrix (or matrices) created by an earlier convolutional layer to a smaller matrix. Pooling usually involves taking either the maximum or average value across the pooled area. Pooling helps enforce translational invariance in the input matrix. Pooling for vision applications is known more formally as spatial pooling. Time-series applications usually refer to pooling as temporal pooling. Less formally, pooling is often called subsampling or downsampling."
   },
   "positive class": {
      "B": "In binary classification, the two possible classes are labeled as positive and negative. The positive outcome is the thing we're testing for. For example, the positive class in a medical test might be \"tumor.\" The positive class in an email classifier might be \"spam.\" Contrast with negative class."
   },
   "precision": {
      "B": "A metric for classification models. Precision indicates how precise the classifier is in predicting the positive class. Precision identifies the frequency with which a model was correct when predicting the positive class. That is: precision is equal to true positives divided by the sum of true positives and false positives"
   },
   "prediction": {
      "B": "A model's output when provided with an input example."
   },
   "prediction bias": {
      "B": "A value indicating how far apart the average of predictions is from the average of labels in the data set. Not to be confused with the bias term in machine learning models or with bias in ethics and fairness."
   },
   "pre trained model": {
      "B": "Models or model components (such as embeddings) that have been already been trained. Sometimes, you'll feed pre-trained embeddings into a neural network. Other times, your model will train the embeddings itself rather than rely on the pre-trained embeddings."
   },
   "prior belief": {
      "B": "What you believe about the data before you begin training on it. For example, L2 regularization relies on a prior belief that weights should be small and normally distributed around zero."
   },
   "proxy labels": {
      "B": "Data used to approximate labels not directly available in a data set. For example, suppose you want is it raining? to be a Boolean label for your data set, but the data set doesn't contain rain data. If photographs are available, you might establish pictures of people carrying umbrellas as a proxy label for is it raining? However, proxy labels may distort results. For example, in some places, it may be more common to carry umbrellas to protect against sun than the rain."
   },
   "rank of a tensor": {
      "B": "The number of dimensions in a Tensor. For instance, a scalar has rank 0, a vector has rank 1, and a matrix has rank 2."
   },
   "ordinality": {
      "B": "The ordinal position of a class in an ML problem that categorizes classes from highest to lowest. For example, a behavior ranking system could rank a dog's rewards from highest (a steak) to lowest (wilted kale)."
   },
   "rater": {
      "B": "A human who provides labels in examples. Sometimes called an \"annotator.\""
   },
   "recall": {
      "B": "A metric for classification models that answers the following question: Out of all the possible positive labels, how many did the model correctly identify? That is: recall is equal to true positives divided by the sum of true positives and false negatives"
   },
   "rectified linear unit": {
      "B": "An activation function with the following rules: If input is negative or zero, output is 0. If input is positive, output is equal to input."
   },
   "relu": {
      "B": "An activation function with the following rules: If input is negative or zero, output is 0. If input is positive, output is equal to input."
   },
   "regression model": {
      "B": "A type of model that outputs continuous (typically, floating-point) values. Compare with classification models, which output discrete values, such as \"day lily\" or \"tiger lily.\""
   },
   "regularization": {
      "B": "The penalty on a model's complexity. Regularization helps prevent overfitting. Different kinds of regularization include: L1 regularization; L2 regularization; dropout regularization; early stopping (this is not a formal regularization method, but can effectively limit overfitting)"
   },
   "regularization rate": {
      "B": "A scalar value, represented as lambda, specifying the relative importance of the regularization function. The following simplified loss equation shows the regularization rate's influence: minimize the sum of loss function and lambda times regularization function. Raising the regularization rate reduces overfitting but may make the model less accurate."
   },
   "reporting bias": {
      "B": "The fact that the frequency with which people write about actions, outcomes, or properties is not a reflection of their real-world frequencies or the degree to which a property is characteristic of a class of individuals. Reporting bias can influence the composition of data that ML systems learn from. For example, in books, the word laughed is more prevalent than breathed. An ML model that estimates the relative frequency of laughing and breathing from a book corpus would probably determine that laughing is more common than breathing."
   },
   "representation": {
      "B": "The process of mapping data to useful features."
   },
   "roc curve": {
      "B": "A curve of true positive rate vs. false positive rate at different classification thresholds. Check also AUC."
   },
   "root mean squared error": {
      "B": "The square root of the Mean Squared Error."
   },
   "rmse": {
      "B": "The square root of the Mean Squared Error."
   },
   "rotational invariance": {
      "B": "In an image classification problem, an algorithm's ability to successfully classify images even when the orientation of the image changes. For example, the algorithm can still identify a tennis racket whether it is pointing up, sideways, or down. Note that rotational invariance is not always desirable; for example, an upside-down 9 should not be classified as a 9."
   },
   "sampling bias": {
      "B": "Check selection bias."
   },
   "scaling": {
      "B": "A commonly used practice in feature engineering to tame a feature's range of values to match the range of other features in the data set. For example, suppose that you want all floating-point features in the data set to have a range of 0 to 1. Given a particular feature's range of 0 to 500, you could scale that feature by dividing each value by 500."
   },
   "scikit learn": {
      "B": "Scikit-learn is an open source software machine learning library for the Python programming language. It features various classification, regression and clustering algorithms including support vector machines, random forests, gradient boosting, k-means and DBSCAN, and is designed to interoperate with the Python numerical and scientific libraries NumPy and SciPy."
   },
   "selection bias": {
      "B": "Errors in conclusions drawn from sampled data due to a selection process that generates systematic differences between samples observed in the data and those not observed. The following forms of selection bias exist:\ncoverage bias: The population represented in the data set does not match the population that the ML model is making predictions about.\nsampling bias: Data is not collected randomly from the target group.\nnon-response bias (also called participation bias): Users from certain groups opt-out of surveys at different rates than users from other groups."
   },
   "semi supervised learning": {
      "B": "Training a model on data where some of the training examples have labels but others don’t. One technique for semi-supervised learning is to infer labels for the unlabeled examples, and then to train on the inferred labels to create a new model. Semi-supervised learning can be useful if labels are expensive to obtain but unlabeled examples are plentiful."
   },
   "sequence model": {
      "B": "A model whose inputs have a sequential dependence. For example, predicting the next video watched from a sequence of previously watched videos."
   },
   "sigmoid function": {
      "B": "A sigmoid function is a mathematical function having a characteristic \"S\"-shaped curve or sigmoid curve. It maps logistic or multinomial regression output (log odds) to probabilities, returning a value between 0 and 1. The sigmoid function has the following formula: 1 divided by 1 plus e to the power of minus x"
   },
   "size invariance": {
      "B": "In an image classification problem, an algorithm's ability to successfully classify images even when the size of the image changes. For example, the algorithm can still identify a cat whether it consumes 2M pixels or 200K pixels. Note that even the best image classification algorithms still have practical limits on size invariance. For example, an algorithm (or human) is unlikely to correctly classify a cat image consuming only 20 pixels."
   },
   "softmax ": {
      "B": "A function that provides probabilities for each possible class in a multi-class classification model. The probabilities add up to exactly 1.0. For example, softmax might determine that the probability of a particular image being a dog at 0.9, a cat at 0.08, and a horse at 0.02."
   },
   "sparse feature": {
      "B": "Feature vector whose values are predominately zero or empty. For example, a vector containing a single 1 value and a million 0 values is sparse. As another example, words in a search query could also be a sparse feature—there are many possible words in a given language, but only a few of them occur in a given query."
   },
   "sparsity": {
      "B": "The number of elements set to zero (or null) in a vector or matrix divided by the total number of entries in that vector or matrix. For example, consider a 10x10 matrix in which 98 cells contain zero. The calculation of sparsity is as follows: 98 divided by 100 is equal to 0.98\nFeature sparsity refers to the sparsity of a feature vector; model sparsity refers to the sparsity of the model weights."
   },
   "squared hinge loss": {
      "B": "The square of the hinge loss. Squared hinge loss penalizes outliers more harshly than regular hinge loss."
   },
   "squared loss": {
      "B": "The loss function used in linear regression. (Also known as L2 Loss.) This function calculates the squares of the difference between a model's predicted value for a labeled example and the actual value of the label. Due to squaring, this loss function amplifies the influence of bad predictions. That is, squared loss reacts more strongly to outliers than L1 loss."
   },
   "static model": {
      "B": "A model that is trained offline."
   },
   "stationarity": {
      "B": "A property of data in a data set, in which the data distribution stays constant across one or more dimensions. Most commonly, that dimension is time, meaning that data exhibiting stationarity doesn't change over time. For example, data that exhibits stationarity doesn't change from September to December."
   },
   "step": {
      "B": "A forward and backward evaluation of one batch."
   },
   "step size": {
      "B": "Synonym for learning rate."
   },
   "stochastic gradient descent": {
      "B": "A gradient descent algorithm in which the batch size is one. In other words, SGD relies on a single example chosen uniformly at random from a data set to calculate an estimate of the gradient at each step."
   },
   "sgd": {
      "B": "A gradient descent algorithm in which the batch size is one. In other words, Stochastic Gradient Descent relies on a single example chosen uniformly at random from a data set to calculate an estimate of the gradient at each step."
   },
   "structural risk minimization": {
      "B": "An algorithm that balances two goals:\nThe desire to build the most predictive model (for example, lowest loss).\nThe desire to keep the model as simple as possible (for example, strong regularization).\nFor example, a function that minimizes loss+regularization on the training set is a structural risk minimization algorithm."
   },
   "stride": {
      "B": "In a convolutional operation or pooling, the delta in each dimension of the next series of input slices. For example in 1,1, stride the next input slice starts one position to the right of the previous input slice. When the operation reaches the right edge, the next slice is all the way over to the left but one position down."
   },
   "sub sampling": {
      "B": "Check pooling"
   },
   "supervised machine learning": {
      "B": "Training a model from input data and its corresponding labels. Supervised machine learning is analogous to a student learning a subject by studying a set of questions and their corresponding answers. After mastering the mapping between questions and answers, the student can then provide answers to new (never-before-seen) questions on the same topic."
   },
   "synthetic features": {
      "B": "A feature not present among the input features, but created from one or more of them. Kinds of synthetic features include the following:\nBucketing a continuous feature into range bins.\nMultiplying (or dividing) one feature value by other feature value(s) or by itself.\nCreating a feature cross.\nFeatures created by normalizing or scaling alone are not considered synthetic features."
   },
   "target": {
      "B": "Synonym for label."
   },
   "temporal data": {
      "B": "Data recorded at different points in time. For example, winter coat sales recorded for each day of the year would be temporal data."
   },
   "tensor": {
      "B": "A tensor is often thought of as a generalized matrix. It could be a 1-D matrix (a vector is actually such a tensor), a 3-D matrix (something like a cube of numbers), even a 0-D matrix (a single number), or a higher dimensional structure that is harder to visualize. The dimension of the tensor is called its rank. They are N-dimensional data structures, most commonly scalars, vectors, or matrices. The elements of a Tensor can hold integer, floating-point, or string values.They describe linear relations between scalars, vectors and other tensors."
   },
   "tensor processing unit": {
      "B": "An ASIC (application-specific integrated circuit) that optimizes the performance of TensorFlow programs."
   },
   "tpu": {
      "B": "An ASIC (application-specific integrated circuit) that optimizes the performance of TensorFlow programs."
   },
   "tensor shape": {
      "B": "The number of elements a Tensor contains in various dimensions. For example, a [5, 10] Tensor has a shape of 5 in one dimension and 10 in another."
   },
   "tensor size": {
      "B": "The total number of scalars a Tensor contains. For example, a [5, 10] Tensor has a size of 50."
   },
   "tensorboard": {
      "B": "The dashboard that displays the summaries saved during the execution of one or more TensorFlow programs."
   },
   "tensor flow": {
      "B": "A large-scale, distributed, machine learning platform. The term also refers to the base API layer in the TensorFlow stack, which supports general computation on dataflow graphs.\nAlthough TensorFlow is primarily used for machine learning, you may also use TensorFlow for non-ML tasks that require numerical computation using dataflow graphs."
   },
   "tensor flow playground": {
      "B": "A program that visualizes how different hyperparameters influence model (primarily neural network) training. Go to http://playground.tensorflow.org to experiment with TensorFlow Playground."
   },
   "test set": {
      "B": "The subset of the data set that you use to test your model after the model has gone through initial vetting by the validation set. Contrast with training set and validation set."
   },
   "time series analysis": {
      "B": "A subfield of machine learning and statistics that analyzes temporal data. Many types of machine learning problems require time series analysis, including classification, clustering, forecasting, and anomaly detection. For example, you could use time series analysis to forecast the future sales of winter coats by month based on historical sales data."
   },
   "training": {
      "B": "The process of determining the ideal parameters comprising a model."
   },
   "training set": {
      "B": "The subset of the data set used to train a model. Contrast with validation set and test set."
   },
   "transfer learning": {
      "B": "Transferring information from one machine learning task to another. Transfer learning might involve transferring knowledge from the solution of a simpler task to a more complex one, or involve transferring knowledge from a task where there is more data to one where there is less data. Most machine learning systems solve a single task. Transfer learning is a baby step towards artificial intelligence in which a single program can solve multiple tasks."
   },
   "translational invariance": {
      "B": "In an image classification problem, an algorithm's ability to successfully classify images even when the position of objects within the image changes. For example, the algorithm can still identify a dog, whether it is in the center of the frame or at the left end of the frame."
   },
   "true negative": {
      "B": "An example in which the model correctly predicted the negative class. For example, the model inferred that a particular email message was not spam, and that email message really was not spam."
   },
   "true positive": {
      "B": "An example in which the model correctly predicted the positive class. For example, the model inferred that a particular email message was spam, and that email message really was spam."
   },
   "true positive rate": {
      "B": "Synonym for recall. That is: true positives divided by the sum of true positives and false negatives. True positive rate is the y-axis in an ROC curve."
   },
   "unlabeled example": {
      "B": "An example that contains features but no label. Unlabeled examples are the input to inference. In semi-supervised and unsupervised learning, unlabeled examples are used during training."
   },
   "unsupervised machine learning": {
      "B": "Training a model to find patterns in a data set, typically an unlabeled data set. The most common use of unsupervised machine learning is to cluster data into groups of similar examples. For example, an unsupervised machine learning algorithm can cluster songs together based on various properties of the music. The resulting clusters can become an input to other machine learning algorithms (for example, to a music recommendation service). Clustering can be helpful in domains where true labels are hard to obtain."
   },
   "validation set": {
      "B": "A subset of the data set—disjunct from the training set—that you use to adjust hyperparameters. Contrast with training set and test set."
   },
   "weight": {
      "B": "A coefficient for a feature in a linear model, or an edge in a deep network. The goal of training a linear model is to determine the ideal weight for each feature. If a weight is 0, then its corresponding feature does not contribute to the model."
   },
   "wide model": {
      "B": "A linear model that typically has many sparse input features. We refer to it as \"wide\" since such a model is a special type of neural network with a large number of inputs that connect directly to the output node. Wide models are often easier to debug and inspect than deep models. Although wide models cannot express nonlinearities through hidden layers, they can use transformations such as feature crossing and bucketization to model nonlinearities in different ways. Contrast with deep model."
   },
   "classification": {
      "B": "classification is the problem of identifying to which of a set of categories or classes a new observation belongs, on the basis of a training set of data containing observations (or instances) whose labels are known. Classification is considered an instance of supervised learning."
   },
   "pytorch": {
      "B": "PyTorch is an open source machine learning library for python, based on Torch. It is a deep learning framework for fast, flexible experimentation. Important features include: Tensor computation (like numpy) with strong GPU acceleration. Dynamic neural networks in Python."
   },
   "cross entropy loss": {
      "B": "A generalization of Log Loss to multi-class classification problems, measures the performance of a classification model whose output is a probability value between 0 and 1. Cross-entropy loss increases as the predicted probability diverges from the actual label. So predicting a probability of .012 when the actual observation label is 1 would be bad and result in a high loss value. A perfect model would have a log loss of 0."
   },
   "log loss": {
      "B": "Logarithmic loss (related to cross-entropy) measures the performance of a classification model where the prediction input is a probability value between 0 and 1. The goal of our machine learning models is to minimize this value. A perfect model would have a log loss of 0. Log loss increases as the predicted probability diverges from the actual label."
   },
   "cross validation": {
      "B": "Cross-validation is a model validation technique for assessing how the results of a statistical analysis will generalize to an independent data set. It is mainly used in settings where the goal is prediction, and one wants to estimate how accurately a predictive model will perform in practice. One round of cross-validation involves partitioning a sample of data into complementary subsets, performing the analysis on one subset (the training set), and validating the analysis on the other subset (the validation set or test set). To reduce variability, in most methods multiple rounds of cross-validation are performed using different partitions, and the validation results are combined over the rounds to give an estimate of the model’s predictive performance."
   },
   "representation learning": {
      "B": "a set of techniques that allows a system to automatically discover the representations needed for feature detection or classification from raw data. Also called feature learning, it replaces manual feature engineering and allows a machine to both learn the features and use them to perform a specific task. Examples include neural networks, multilayer perceptron, autoencoders and various forms of clustering"
   },
   "feature learning": {
      "B": "a set of techniques that allows a system to automatically discover the representations needed for feature detection or classification from raw data. Also called representation learning, it replaces manual feature engineering and allows a machine to both learn the features and use them to perform a specific task. Examples include neural networks, multilayer perceptron, autoencoders and various forms of clustering"
   },
   "principal component analysis": {
      "B": "Principal component analysis is a statistical procedure. It uses an orthogonal transformation to convert a set of observations of possibly correlated variables into a set of linearly uncorrelated variables called principal components. If there are n observations with p variables, then the number of distinct principal components is minimum of (n minus 1 and p). This transformation is defined in such a way that the first principal component has the largest possible variance (accounting for as much of the variability in the data as possible), and each succeeding component in turn has the highest variance possible under the constraint that it is orthogonal to the preceding components."
   },
   "pca": {
      "B": "Principal component analysis is a statistical procedure. It uses an orthogonal transformation to convert a set of observations of possibly correlated variables into a set of linearly uncorrelated variables called principal components. If there are n observations with p variables, then the number of distinct principal components is minimum of (n minus 1 and p). This transformation is defined in such a way that the first principal component has the largest possible variance (accounting for as much of the variability in the data as possible), and each succeeding component in turn has the highest variance possible under the constraint that it is orthogonal to the preceding components."
   },
   "kl divergence": {
      "B": "In mathematical statistics, the Kullback–Leibler divergence (also called relative entropy) is a measure of how one probability distribution diverges from a second, expected probability distribution."
   },
   "adam optimization": {
      "B": "The Adam Optimization algorithm is used in training deep learning models. It is an extension to Stochastic Gradient Descent. In this optimization algorithm, running averages of both the gradients and the second moments of the gradients are used. It is used to compute adaptive learning rates for each parameter.\nFeatures:\nIt is computationally efficient and has little memory requirements\nIt is invariant to diagonal rescaling of the gradients\nAdam works well in practice as compared to other stochastic optimization methods"
   },
   "bagging": {
      "B": "Bagging or bootstrap averaging is a technique where multiple models are created on the subset of data, and the final predictions are determined by combining the predictions of all the models. Some of the algorithms that use bagging technique are : Bagging meta-estimator, Random Forest"
   },
   "boosting": {
      "B": "Boosting is a sequential process, where each subsequent model attempts to correct the errors of the previous model. The succeeding models are dependent on the previous model. Some of the boosting algorithms are: AdaBoost, Gradient Boosting, XGBM, LightGBM"
   },
   "correlation": {
      "B": "Correlation is the ratio of covariance of two variables to a product of variance (of the variables). It takes a value between +1 and -1. An extreme value on both the side means they are strongly correlated with each other. A value of zero indicates a NIL correlation but not a non-dependence."
   },
   "cosine similarity": {
      "B": "Cosine Similarity is the cosine of the angle between 2 non-zero vectors. Two parallel vectors have a cosine similarity of 1 and two vectors at 90 degrees have a cosine similarity of 0. Suppose we have two vectors A and B, cosine similarity of these vectors can be calculated by dividing the dot product of A and B with the product of the magnitude of the two vectors."
   },
   "db scan": {
      "B": "DBSCAN is the acronym for Density-Based Spatial Clustering of Applications with Noise. It is a clustering algorithm that isolates different density regions by forming clusters. For a given set of points, it groups the points which are closely packed."
   },
   "decision boundary": {
      "B": "In a statistical-classification problem with two or more classes, a decision boundary or decision surface is a hypersurface that partitions the underlying vector space into two or more sets, one for each class. How well the classifier works depends upon how closely the input patterns to be classified resemble the decision boundary."
   },
   "decision tree": {
      "B": "Decision tree is a type of supervised learning algorithm (having a pre-defined target variable) that is mostly used in classification problems. It works for both categorical and continuous input & output variables. In this technique, we split the population (or sample) into two or more homogeneous sets (or sub-populations) based on most significant splitter / differentiator in input variables."
   },
   "f1 score": {
      "B": "In statistical analysis of binary classification, the F1 score (also F-score or F-measure) is a measure of a test's accuracy. The F1 score is the harmonic average of the precision and recall, where an F1 score reaches its best value at 1 (perfect precision and recall) and worst at 0."
   }
}
